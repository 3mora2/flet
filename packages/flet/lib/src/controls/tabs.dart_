import 'dart:convert';

import 'package:flet/flet.dart';
import '../flet_backend.dart';
import '../utils/numbers.dart';
import 'package:flutter/material.dart';

import '../flet_backend.dart';
import '../models/control.dart';
import '../utils/alignment.dart';
import '../utils/borders.dart';
import '../utils/colors.dart';
import '../utils/edge_insets.dart';
import '../utils/icons.dart';
import '../utils/material_state.dart';
import '../utils/mouse.dart';
import '../utils/misc.dart';
import '../utils/text.dart';
import 'base_controls.dart';

class TabsControl extends StatefulWidget {
  final Control control;
  const TabsControl({super.key, required this.control});

  @override
  State<TabsControl> createState() => _TabsControlState();
}

class _TabsControlState extends State<TabsControl>
    with TickerProviderStateMixin {
  String? _tabsSnapshot;
  TabController? _tabController;
  int _selectedIndex = 0;

  @override
  void dispose() {
    _tabController?.removeListener(_tabChanged);
    _tabController?.dispose();
    super.dispose();
  }

  void _tabChanged() {
    if (_tabController!.indexIsChanging == true) {
      return;
    }
    var index = _tabController!.index;
    if (_selectedIndex != index) {
      debugPrint("Selected index: $index");
      widget.control.updateProperties({"selected_index": index}, context);
      widget.control.triggerEvent("change", context, index);
      _selectedIndex = index;
    }
  }

  @override
  Widget build(BuildContext context) {
    debugPrint("TabsControl build: ${widget.control.id}");

    var tabs = StoreConnector<AppState, ControlsViewModel>(
        distinct: true,
        converter: (store) => ControlsViewModel.fromStore(
            store, widget.control.children("tabs").map((c) => c.id)),
        builder: (content, viewModel) {
          var tabsSnapshot =
              viewModel.controlViews.map((c) => c.control.id).join();
          if (tabsSnapshot != _tabsSnapshot) {
            _tabsSnapshot = tabsSnapshot;

            if (_tabController != null) {
              _tabController!.removeListener(_tabChanged);
              _tabController!.dispose();
            }
            _tabController = TabController(
                length: viewModel.controlViews.length,
                animationDuration: widget.control.getDuration(
                    "animation_duration", const Duration(milliseconds: 50))!,
                vsync: this);
            _tabController!.addListener(_tabChanged);
          }

          var selectedIndex = widget.control.getInt("selected_index", 0)!;

          if (selectedIndex > -1 &&
              selectedIndex < _tabController!.length &&
              _selectedIndex != selectedIndex) {
            _selectedIndex = selectedIndex;
            _tabController!.index = selectedIndex;
          }

          // check if all tabs have no content
          bool emptyTabs = !viewModel.controlViews.any(
              (t) => t.children.any((c) => c.name == "content" && c.visible));

          var overlayColor = widget.control.getWidgetStateColor(
              "overlay_color", Theme.of(context),
              defaultValue: TabBarTheme.of(context).overlayColor)!;
          var indicatorBorderRadius =
              widget.control.getBorderRadius("indicator_border_radius");
          var indicatorBorderSide = widget.control
              .getBorderSide("indicator_border_side", Theme.of(context));
          var indicatorPadding = widget.control.getPadding("indicator_padding");
          var indicatorColor = widget.control.getColor(
              "indicator_color",
              context,
              TabBarTheme.of(context).indicatorColor ??
                  Theme.of(context).colorScheme.primary)!;
          var labelColor = widget.control.getColor(
              "label_color",
              context,
              TabBarTheme.of(context).labelColor ??
                  Theme.of(context).colorScheme.primary);
          var unselectedLabelColor = widget.control.getColor(
              "unselected_label_color",
              context,
              TabBarTheme.of(context).unselectedLabelColor ??
                  Theme.of(context).colorScheme.onSurface);
          var dividerColor =
              widget.control.getColor("divider_color", context) ??
                  TabBarTheme.of(context).dividerColor;
          var themeIndicator =
              TabBarTheme.of(context).indicator as UnderlineTabIndicator?;
          var indicatorTabSize = widget.control.getBool("indicator_tab_size");
          var isScrollable = widget.control.getBool("scrollable", true)!;
          var secondary = widget.control.getBool("is_secondary", false)!;
          var dividerHeight = widget.control.getDouble("divider_height");
          var enableFeedback = widget.control.getBool("enable_feedback");
          var indicatorWeight =
              widget.control.getDouble("indicator_thickness", 2.0)!;
          var tabAlignment = parseTabAlignment(
              widget.control.getString("tab_alignment"),
              isScrollable ? TabAlignment.start : TabAlignment.fill)!;
          var mouseCursor =
              parseMouseCursor(widget.control.getString("mouse_cursor"));
          var clipBehavior =
              widget.control.getClipBehavior("clip_behavior", Clip.hardEdge)!;
          var padding = parseEdgeInsets(widget.control.getPadding("padding"));
          var labelPadding = widget.control.getPadding("label_padding");
          var labelStyle = widget.control
              .getTextStyle("label_text_style", Theme.of(context));
          var unselectedLabelStyle = widget.control
              .getTextStyle("unselected_label_text_style", Theme.of(context));
          var splashBorderRadius =
              widget.control.getBorderRadius("splash_border_radius");

          void onTap(int index) {
            widget.control.triggerEvent("click", context, index);
          }

          var indicator = indicatorBorderRadius != null ||
                  indicatorBorderSide != null ||
                  indicatorPadding != null
              ? UnderlineTabIndicator(
                  borderRadius: indicatorBorderRadius ??
                      themeIndicator?.borderRadius ??
                      const BorderRadius.only(
                          topLeft: Radius.circular(2),
                          topRight: Radius.circular(2)),
                  borderSide: indicatorBorderSide ??
                      themeIndicator?.borderSide ??
                      BorderSide(
                          width: themeIndicator?.borderSide.width ?? 2,
                          color: themeIndicator?.borderSide.color ??
                              indicatorColor),
                  insets: indicatorPadding ??
                      themeIndicator?.insets ??
                      EdgeInsets.zero)
              : TabBarTheme.of(context).indicator;
          var indicatorSize = indicatorTabSize != null
              ? (indicatorTabSize
                  ? TabBarIndicatorSize.tab
                  : TabBarIndicatorSize.label)
              : TabBarTheme.of(context).indicatorSize;

          var tabs = viewModel.controlViews.map((tabView) {
            var iconStr = tabView.control.getIcon("icon");
            var icon = tabView.control.buildWidget("icon") ??
                (iconStr != null ? Icon(iconStr) : null);
            var label = tabView.control.buildWidget("label") ??
                tabView.control.buildWidget(
                    "tab_content"); // todo(0.70.3): remove "tab_content"
            var labelStr = tabView.control.getString("label") ??
                tabView.control
                    .getString("text") ?? // todo(0.70.3): remove "text"
                (icon == null ? "" : null);

            return Tab(
              icon: icon,
              height: tabView.control.getDouble("height"),
              iconMargin: tabView.control.geMargin("icon_margin"),
              text: label != null
                  ? null // either one of text or child can be set; we give child priority as it's more specific
                  : labelStr,
              child: label,
            );
          }).toList();

          TabBar? tabBar;

          if (secondary) {
            tabBar = TabBar.secondary(
                tabAlignment: tabAlignment,
                controller: _tabController,
                isScrollable: isScrollable,
                dividerHeight: dividerHeight,
                enableFeedback: enableFeedback,
                mouseCursor: mouseCursor,
                indicatorWeight: indicatorWeight,
                dividerColor: dividerColor,
                indicatorSize: indicatorSize,
                indicator: indicator,
                indicatorColor: indicatorColor,
                labelColor: labelColor,
                unselectedLabelColor: unselectedLabelColor,
                overlayColor: overlayColor,
                tabs: tabs,
                padding: padding,
                labelPadding: labelPadding,
                labelStyle: labelStyle,
                unselectedLabelStyle: unselectedLabelStyle,
                splashBorderRadius: splashBorderRadius,
                indicatorPadding: indicatorPadding ?? EdgeInsets.zero,
                onTap: onTap);
          } else {
            tabBar = TabBar(
                tabAlignment: tabAlignment,
                controller: _tabController,
                isScrollable: isScrollable,
                dividerHeight: dividerHeight,
                enableFeedback: enableFeedback,
                mouseCursor: mouseCursor,
                indicatorWeight: indicatorWeight,
                dividerColor: dividerColor,
                indicatorSize: indicatorSize,
                indicator: indicator,
                indicatorColor: indicatorColor,
                labelColor: labelColor,
                unselectedLabelColor: unselectedLabelColor,
                overlayColor: overlayColor,
                tabs: tabs,
                padding: padding,
                labelPadding: labelPadding,
                labelStyle: labelStyle,
                unselectedLabelStyle: unselectedLabelStyle,
                splashBorderRadius: splashBorderRadius,
                indicatorPadding: indicatorPadding ?? EdgeInsets.zero,
                onTap: onTap);
          }

          if (emptyTabs) {
            return tabBar;
          }

          return Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              tabBar,
              Expanded(
                  child: TabBarView(
                      controller: _tabController,
                      clipBehavior: clipBehavior,
                      children: viewModel.controlViews.map((tabView) {
                        return tabView.buildWidget("content") ??
                            const SizedBox.shrink();
                      }).toList()))
            ],
          );
        });

    return ConstrainedControl(control: widget.control, child: tabs);
  }
}
