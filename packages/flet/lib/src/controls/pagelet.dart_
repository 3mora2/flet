import 'package:collection/collection.dart';
import 'package:flet/flet.dart';
import 'package:flutter/cupertino.dart';
import 'package:flutter/material.dart';

import '../flet_backend.dart';
import '../models/control.dart';
import '../models/page_design.dart';
import '../utils/buttons.dart';
import '../widgets/error.dart';
import '../widgets/flet_store_mixin.dart';
import 'app_bar.dart';
import 'base_controls.dart';
import 'cupertino_app_bar.dart';
import 'navigation_drawer.dart';
import 'page.dart';

class PageletControl extends StatefulWidget {
  final Control control;

  const PageletControl({super.key, required this.control});

  @override
  State<PageletControl> createState() => _PageletControlState();
}

class _PageletControlState extends State<PageletControl> with FletStoreMixin {
  final scaffoldKey = GlobalKey<ScaffoldState>();

  @override
  Widget build(BuildContext context) {
    debugPrint("Pagelet build: ${widget.control.id}");

    var appBar = widget.control.buildWidget("appbar");
    var content = widget.control.buildWidget("content");
    var navigationBar = widget.control.buildWidget("navigationbar");
    var bottomAppBar = widget.control.buildWidget("bottomappbar");
    var bottomSheet = widget.control.buildWidget("bottomsheet");
    var drawer = widget.control.buildWidget("drawer");
    var endDrawer = widget.control.buildWidget("enddrawer");
    var fab = widget.control.buildWidget("floatingactionbutton");

    if (content == null) {
      return const ErrorControl("Pagelet.content must be provided and visible");
    }

    return withPagePlatform((context, platform) {
      var widgetsDesign = widget.control.adaptive == true &&
              (platform == TargetPlatform.iOS ||
                  platform == TargetPlatform.macOS)
          ? PageDesign.cupertino
          : PageDesign.material;

      List<String> childIds = [
        appBar.firstOrNull?.id,
        drawer.firstOrNull?.id,
        endDrawer.firstOrNull?.id
      ].nonNulls.toList();

      return StoreConnector<AppState, ControlsViewModel>(
          distinct: true,
          converter: (store) => ControlsViewModel.fromStore(store, childIds),
          ignoreChange: (state) {
            //debugPrint("ignoreChange: $id");
            for (var id in childIds) {
              if (state.controls[id] == null) {
                return true;
              }
            }
            return false;
          },
          builder: (context, childrenViews) {
            var bnb = navigationBar ?? bottomAppBar;

            var appBarView = childrenViews.controlViews.firstWhereOrNull(
                (v) => v.control.id == (appBar.firstOrNull?.id ?? ""));

            var drawerView = childrenViews.controlViews.firstWhereOrNull(
                (v) => v.control.id == (drawer.firstOrNull?.id ?? ""));
            var endDrawerView = childrenViews.controlViews.firstWhereOrNull(
                (v) => v.control.id == (endDrawer.firstOrNull?.id ?? ""));

            final bool? drawerOpened = widget.control.state["drawerOpened"];
            final bool? endDrawerOpened =
                widget.control.state["endDrawerOpened"];

            final fabLocation = widget.control.getFloatingActionButtonLocation(
                "floatingActionButtonLocation",
                FloatingActionButtonLocation.endFloat);

            void dismissDrawer(String id) {
              widget.control.updateProperties({"open": "false"}, context);
              widget.control.triggerEvent("dismiss", context);
            }

            WidgetsBinding.instance.addPostFrameCallback((_) {
              if (drawerView != null) {
                if (scaffoldKey.currentState?.isDrawerOpen == false &&
                    drawerOpened == true) {
                  widget.control.state["drawerOpened"] = false;
                  dismissDrawer(drawerView.control.id
                  );
                }
                if (drawerView.control.getBool("open", false)! &&
                    drawerOpened != true) {
                  if (scaffoldKey.currentState?.isEndDrawerOpen == true) {
                    scaffoldKey.currentState?.closeEndDrawer();
                  }
                  Future.delayed(const Duration(milliseconds: 1)).then((value) {
                    scaffoldKey.currentState?.openDrawer();
                    widget.control.state["drawerOpened"] = true;
                  });
                } else if (!drawerView.control.getBool("open", false)! &&
                    drawerOpened == true) {
                  scaffoldKey.currentState?.closeDrawer();
                  widget.control.state["drawerOpened"] = false;
                }
              }
              if (endDrawerView != null) {
                if (scaffoldKey.currentState?.isEndDrawerOpen == false &&
                    endDrawerOpened == true) {
                  widget.control.state["endDrawerOpened"] = false;
                  dismissDrawer(endDrawerView.control.id);
                }
                if (endDrawerView.control.getBool("open", false)! &&
                    endDrawerOpened != true) {
                  if (scaffoldKey.currentState?.isDrawerOpen == true) {
                    scaffoldKey.currentState?.closeDrawer();
                  }
                  Future.delayed(const Duration(milliseconds: 1)).then((value) {
                    scaffoldKey.currentState?.openEndDrawer();
                    widget.control.state["endDrawerOpened"] = true;
                  });
                } else if (!endDrawerView.control.getBool("open", false)! &&
                    endDrawerOpened == true) {
                  scaffoldKey.currentState?.closeEndDrawer();
                  widget.control.state["endDrawerOpened"] = false;
                }
              }
            });

            var bar = appBarView != null
                ? appBarView.control.type == "appbar"
                    ? widgetsDesign == PageDesign.cupertino
                        ? CupertinoAppBarControl(control: appBarView.control)
                        : AppBarControl(control: appBarView.control
                            // height: appBarView.control
                            //     .getDouble("toolbarHeight", kToolbarHeight)!
                            )
                    : appBarView.control.type == "cupertinoappbar"
                        ? CupertinoAppBarControl(control: appBarView.control)
                            as ObstructingPreferredSizeWidget
                        : null
                : null;

            Widget scaffold = Scaffold(
                key: bar == null || bar is AppBarControl ? scaffoldKey : null,
                backgroundColor: widget.control.getColor("bgcolor", context) ??
                    CupertinoTheme.of(context).scaffoldBackgroundColor,
                appBar: bar is AppBarControl ? bar : null,
                drawer: drawerView != null
                    ? NavigationDrawerControl(control: drawerView.control)
                    : null,
                onDrawerChanged: (opened) {
                  if (drawerView != null && !opened) {
                    widget.control.state["drawerOpened"] = false;
                    dismissDrawer(drawerView.control.id);
                  }
                },
                endDrawer: endDrawerView != null
                    ? NavigationDrawerControl(control: endDrawerView.control)
                    : null,
                onEndDrawerChanged: (opened) {
                  if (endDrawerView != null && !opened) {
                    widget.control.state["endDrawerOpened"] = false;
                    dismissDrawer(endDrawerView.control.id);
                  }
                },
                body: content,
                bottomNavigationBar: bnb,
                bottomSheet: bottomSheet,
                floatingActionButton: fab,
                floatingActionButtonLocation: fabLocation);

            if (bar is CupertinoAppBarControl) {
              scaffold = CupertinoPageScaffold(
                  key: scaffoldKey,
                  backgroundColor: widget.control.getColor("bgcolor", context),
                  navigationBar: bar as ObstructingPreferredSizeWidget,
                  child: scaffold);
            }

            return ConstrainedControl(control: widget.control, child: scaffold);
          });
    });
  }
}
